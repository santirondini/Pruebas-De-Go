------------------------------------------------------
VARIABLES

noTipado := 1234
var tipadoSinValor int 
var tipadoConValor int = 1231

var nombreDeVariable tipo

Tipos Basicos:

var soyUnBooleano bool;
var soyUnMensaje string;
var soyUnEntero int;
var soyUnFlotante float32;
var soyUnByte byte;

fmt.Scanln(&frase) ==> lee una frase hasta el espacio 

fmt.Println("Frase...", variable a mostrar por pantalla)

Floats:

var float32
var float64

Si no le asignamos valor, automaticamente va a ser 0

Byte: represetna un numero entero de 8bits sin signo. Su dato por defecto es 0 

Tipos de Datos Compuestos:
<
-------------

* array => colecci√≥n de elementos del mismo tipo

Declaraci√≥n: 
- var arraySinVaor [5]int 
- var arrarConValores [5]int = [5]int{1,2,3,4,5}

Esta en base 0

-------------

* slice => similar al array, pero su tama√±o puede ser modificado dinamicamente 

Declaraci√≥n: 
- var sliceSinValor []int 
- var sliceConValores []int = []int{1,2,3,4,5}

Sacar tama√±o:

var tamanioSliceConValor = len(sliceConValores)
fmt.Println("El tama√±o del slice es:",tamanioSliceConValor)

Agregar valor:

sliceConValor = append(sliceConValor, 6)

Imprimo el nuevo tama√±o del slice con valor:
	
tama√±oSliceConValor = len(sliceConValor)
fmt.Println("Nuevo tama√±o del slice con valor: ", tama√±oSliceConValor)

Imprimo el nuevo Slice:
fmt.Println("Nuevo slice con valor: ", sliceConValor)

Tambien sus indices estan en base 0
Go no posee la funci√≥n de eliminar un inidce en aprticular de una slice, sino que debe hacerse a trave√©s de hacer cub slice;
quedarse con una aprte del slice original:

var mySlice []int = []int{1, 2, 3, 4, 5}

Para obtener los primeros dos elementos del array
fmt.Println("Primeros dos elementos:", mySlice[:2])

Para quedarme con todos los elementos posterior al indice 2 (inclusive)
fmt.Println("Ultimos elementos:", mySlice[2:])

Para quitar el elemento de indice 2
fmt.Println("Slice sin el elemento 3:", append(mySlice[:2], mySlice[2+1:]...))

-------------

* map => colecci√≥n de pares clave-valor. Ejemplo: 
    var miMapa map[string]int ==> se declara un map donde las claves son strings y los valores de tipo int 

Inicializaci√≥n: 
1) miMapa = make(map[string]int)
2) miMapa := map[string]int {
    "uno": 1,
    "dos": 2,
}

Operaciones basicas:

- miMapa["tres"] = 3
- valor := miMapa["uno"]
- delete(miMapa, "dos") ==> eliminar una clave
- Agregar valor a un map:
mapNombresEdad["Nahuel"] = 32

-------------

* struct: representa un conjunto de campos con diferentes tipos de datos 

Declaraci√≥n:

type Nombre struct {
    nombreVariable1 tipo1
    nombreVariable2 tipo2
    nombreVariable3 tipo3
    ..
}

var persona Persona = Persona{"Nahuel",32,1.77}
- Acceder a una unica propiedad:
    nombreDelStructCreado.atributo

- Redefinir: 
    nombreDelStructCreado.atributo = valorNuevo

-------------

Transformaci√≥n cadena <=> byte 

Por diferentes razones, hrbra que transformar una cadena(string) en un array de bytes:
COMO HACERLO:

1) Definimos estos datos:

    var cadena string = "Hola"
	var arrayBytes []byte

2) transformamos la cadena en array de bytes:

	Transformamos nuestra cadena en un array de bytes
	arrayBytes = []byte(cadena)

3) Imprimir el array:

	fmt.Println("Array de bytes:", arrayBytes)

4) Convertimos el array de bytes en una cadena
	
    var nuevaCadena string = string(arrayBytes)

5)  Imprimimos la nueva cadena
	
    fmt.Println("Nueva cadena:", nuevaCadena)

Por Consola: 
        Array de bytes: [72 111 108 97]
        Nueva cadena: Hola

Van a existir simobolos que ocupen mas de un byte. Ej: la cadena "ABC‚Ç¨"
Si la pasamos un array de bytes, queda:
    [65 66 67 226 130 172]  

‚Ç¨ en UTF-8 es representado por 3 bytes.  
Si en algun momento hay que guardas cosas en un []byte hay que saber que no siempre una secuencia de N caracteres
ocuparan N bytes. Se puede usar len().

------------------------------------------------------

FUNCIONES

Palabra reservada func. Deben ser declaradas por medio de una firma en la cual se especifiquen los valores que recibe y/o retorna. Ej:

func sumar(a int, b int) int {
	return a + b
}

-------------

Scopes: la region en al que existe una variable o funcion dentro de nuestro codigo. Donde se puede acceder a ellos. Ej:

func main() {
	var valor1 int = 1
	var valor2 int = 2

	var suma int = sumar(valor1, valor2)

	fmt.Println("Resultado:", suma)
}

func sumar(a int, b int) int {
	return a + b
}

Tanto valor1 como valor2 estan dentro del scope de main. Unicamente pueden usarse ahi. Ahora:

var valor1 int = 3

func main() {
	var valor2 int = 2

	fmt.Println("Resultado sumar2:", sumar2(valor2))
}

func sumar2(b int) int {
	return valor1 + b
}

valor1 es una variable declarada de forma GLOBAL, pudiendo acceder a la func sumar2
El objetivo de esto es cuidar como se nombran las variables en el codigo. Go va a tomar el valor 
de la bariable en el scope en que el estemos trabajando en ese momento. Podemos declarar funciones dentro 
de otras:

func main() {
	var valor1 int = 1
	var valor2 int = 2

	var sumar = func(a int, b int) int {
		return a + a + b
	}

	fmt.Println("Resultado sumar:", sumar(valor1, valor2))
}

func sumar(a int, b int) int {
	return a + b
}

------------------------------------------------------

OPERADORES

Operadores Aritmeticos:

- Incremento: variable++
- Decremento: variable--
- Signo: 
    var i int = 10
    fmt.Println("+i =", +i)
    fmt.Println("-i =", -i)
- Complemento: ^ . Complemento de una variable bit a bit. 
- Negaci√≥n: ! . Negaci√≥n de una variable booleana.
- Logicos: <, >, <=, >=, ==, !=
- Condicionales: &&, ||, !
- Asignaci√≥n: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=

------------------------------------------------------

SENTENCIAS

---------

If - Then: 

func main() {
	var edad int = 15
	if edad < 18 {
		fmt.Println("Menor de edad!")
	}
}

---------

If - Then - Else:

func main() {
	var edad int = 19;
	if edad < 18 {
		fmt.Println("Menor de edad!")
	} else {
		fmt.Println("Mayor de edad!")
	}
}

---------

If - Then - Else - If:

func main() {
	var edad int = 76;
	if edad < 18 {
		fmt.Println("Menor de edad!")
	} else if(edad < 75) {
		fmt.Println("Mayor de edad!")
	} else {
		fmt.Println("Jubilado")
	}
}

---------

Switch: 

func main() {
	funcionCase("A")
	funcionCase("D")
	funcionCase("J")
}

func funcionCase(a string) {
	switch a {
	case "A":
		fmt.Println("Abeja")
	case "B":
		fmt.Println("Baskett")
	case "C":
		fmt.Println("Codigo")
	case "D":
		fmt.Println("Dado")
	default:
		fmt.Println("No se que es!")
	}
}

---------

For: 

func main() {
	for i:=0; i < 10; i++ {
		fmt.Print(i, " ")
	}
}

---------

While: 

func main() {
	i := 0
	for i < 10 {
		fmt.Print(i, " ")
		i++
	}
}

------------------------------------------------------

HILOS 

definici√≥n: tarea que puede ser ejecutada al mismo tiempo que otra. Comparte recursos del proceso padre que lo ejecuta
y existen herramientas para comunicar distintos hilos entre si.
Los hilos son una forma de paralelizar el trabajo, pero no son la unica.

Cuando nuestro programa tiene que hacer mas de una cosa a la vez => usamos Hilos

Tipos de Hilos:

    1) Hilos de usuario: son aquellos que son creados por el usuario. Se ejecutan en el espacio de usuario y no tienen 
        acceso directo a los recursos del sistema operativo. Este hilo solo existe dentro del un proceso, por lo cual
        no puede hacer referencia a un hilo de otro. El S.O no sabe que existen, solo reconoce hilos en ejecuccion.

    2) Hilos de Kernel: son aquellos que son creados por el sistema operativo. Se ejecutan en el espacio del kernel y 
        tienen acceso directo a los recursos del sistema operativo.

Golang (el maldito Gopher) permite la creaci√≥n de hilos y les llama "Rutinas". Estas son hilos de usuario. 
Dentro del motor existe un planificador que administra dichas rutinas dentro de hilos de kernel. Los hilos de usuario
corren en hilos de kernel. Caracteristicas:

- Son muy livianos. Se pueden crear millones de rutinas sin problemas.
- Se comunican entre si mediante canales (channels).
- Si una gorutine se bloquea, el planificador puede ejecutar otra gorutine.
 
Ejemplo de video: https://www.youtube.com/watch?v=4FrZjGXSBZo

func Hello(){
    fmt.Println("Hello, world!")
}

func main(){
    go Hello() // Lanza la gorutina
    time.Sleep(1 * time.Second) // Espera 1 segundo para que la gorutina termine
}

Cuando lo corremos por consola, nos imprime Hello, world! despues de un segundo y termina el programa.

----------

Rutinas Golang:

var valor int = 0

func main() {

	for i := 0; i < 20; i++ {
		thread()
	}
}

func thread() {
	valor++
	fmt.Println("Este es el hilo n√∫mero", valor)
}

Consola: 

Este es el hilo n√∫mero 1
Este es el hilo n√∫mero 2
.
.
.
Este es el hilo numero 20

Ejemplo 2: 

var valor int = 0

func main() {

	for i := 0; i < 20; i++ {
		go thread() 
	}

	//Este tiempo es importante debido a que si el hilo
	//principal termina antes, los hilos no se
	//ejecutar√°n
	time.Sleep(101 * time.Second)
}

func thread() {
	valor++
	fmt.Println("Este es el hilo n√∫mero", valor)
}

Por consola van a largarse "Este es el hilo numero x" pero no se forma continua como antes.
Agregando el go adelante de la funcio thread() hizo que genera una rutina que atienda la ejecuccion de dicha funcion 

Agreando el go, lanzamos multiples funciones que se ejecutan al mismo tiempo y por eso no hay un orden garantizado. Le decis 
a go: "ejecut√° esta funci√≥n en una goroutine aparte y no te quedes esperando a que termine". Esto genera que las goroutines se ejecuten 
cuando pueden, en paralelo o intercaladas. 

Las rutinas son hilos "hijos" del proceso main y si diche funcion finaliza, las rutinas tambien mueren. Debido a esto,
agregarmos un Sleep para lograr que dicha funcion no finalice antes que lo hagan sus rutinas.

Condiciones de Carrera: debido a que todas las rutinas estan compitiendo para utilizar la variable valor y que son planificadas, 
se gener√≥ que los resultados ya no sean deterministicos. Los hilos se planifican primero por el Scheduler de Go y luego por el S.O

Las goroutines son tareas paralelas al resto del codigo del programa, incluyndo al main() (hilo principal) y otras rutinas. 
------------------------------------------------------

SINCRONIZACI√ìN 

Coordinar y ordenar dos acciones que pueden ocurrir al mismo tiempo para que solo una lo haga. Dentro de Go existen tres herramientas 
principales para sincronizar rutinas:
    - sync.WaitGroup
    - sync.Mutex
    - Canales: 'chan'

----------

sync.WaitGroup: se utiliza para esperar la finalizaci√≥n de un grupo de rutinas. Permite que una gourutine espere hasta que todas 
las rutinas en el grupo hayan completo su ejecuccion. NO SINCRONIZA RECURSOS.
    - Sintaxis: Metodos como Add(), Done() y Wait(). 
        - Add(): incrementa el contador 
        - Done(): decrementa el contador
        - Wait(): bloquea hasta que el contador llegue a 0

Ejemplo: 

var wg sync.WaitGroup

for i := 0; i < 3; i+ + { => cada iteracion lanza una goroutine
    wg.Add(1) => le dice al WaitGroup que espere una goroutine mas, aumentando el contador con Add(1) 
    go func(id int) { => crea una goroutine anonima (funcion anonima que se ejecuta en paralelo) pasando como parametro el id 
        defer wg.Done() => difiere la ejecuccion de wg.Done() hasta que termien la funcion 
        // Hacer alg√∫n trabajo => Codigo real de goroutine que estamos ejectuando
        // ...
    }(i) => ejectua la funcion anonima pasandole el id como argumento
}

// Esperar a que todas las goroutines completen
wg.Wait() => Esto se ejecuta despues del bucle hasta el que contador WaitGroup llegue a 0, es decir, que todas las goroutines hayan terminado su ejecuccion.

Para entender que pija son las gourtine, el shatCGT me tiro este ejemplo para romperle el culo a gopher: 

Vos sos el director (el main() de Go), y quer√©s que 3 actores digan su di√°logo al mismo tiempo, mientras vos esper√°s en el escenario.
Cada actor es una goroutine. Pero como sos un buen director, no te quer√©s ir del escenario hasta que los 3 terminen su parte. ¬øC√≥mo sab√©s cu√°ndo terminan?

üìå ¬°Necesit√°s un contador!

Cada vez que un actor sale a escena (goroutine), sum√°s 1 al contador.
Cuando termina de hablar, el actor resta 1.
Vos, el director, us√°s wg.Wait() para quedarte parado esperando a que el contador llegue a 0.

Aclaraci√≥n: el main() es una funcion especial de go. Esta cuando termina, el programa se cierra completamente aunque hayan gourtines todavia trabajando.
Por eso hascemos el wg.Wait() para que el main() espere a que todas las goroutines terminen su trabajo antes de cerrar el programa. Basicamente hacemos 
esperar al main() hasta que todas las goroutines terminen su trabajo. 

------------

sync.Mutex

Se utiliza par lograr exclusi√≥n mutua y evitar condiciones de carrera en secciones criticas de codigo. Garantiza que solo una rutina pueda acceder a 
una secci√≥n critica a la vez. 
    - Sintaxis: 
        - Lock(): bloquea el mutex, evitando que otras goroutines accedan a la secci√≥n cr√≠tica.
        - Unlock(): desbloquea el mutex, permitiendo que otras goroutines accedan a la secci√≥n cr√≠tica.

Ejemplo: 

var mu sync.Mutex

// Secci√≥n cr√≠tica protegida por el mutex
mu.Lock()
// Acciones en la secci√≥n cr√≠tica
mu.Unlock()

-----------

Canales 

Se utilizan para comunicar y sincronizar rutinas. Permite acceso desde corrdinar y sincronizar secciones criticas de codigo hasta el envio y recepeci√≥n de
datos entre rutinas. 
    - Sintaxis: 
        - make(chan tipo): crea un canal de un tipo especifico
        - canal <- valor: envia un valor al canal
        - valor := <- canal: recibe un valor del canal

Ejemplo: 

ch := make(chan int)

go func() {
    // Hacer alg√∫n trabajo
    // ...
    ch <- 42 // Enviar datos al canal
}()

// Recibir datos del canal
valor := <-ch

